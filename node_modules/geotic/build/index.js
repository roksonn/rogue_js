function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = privateMap.get(receiver);

  if (!descriptor) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = privateMap.get(receiver);

  if (!descriptor) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
  }

  return value;
}

const preserveCamelCase = string => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;

  for (let i = 0; i < string.length; i++) {
    const character = string[i];

    if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
      string = string.slice(0, i) + '-' + string.slice(i);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      i++;
    } else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
      string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = character.toLocaleLowerCase() === character && character.toLocaleUpperCase() !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = character.toLocaleUpperCase() === character && character.toLocaleLowerCase() !== character;
    }
  }

  return string;
};

const camelCase = (input, options) => {
  if (!(typeof input === 'string' || Array.isArray(input))) {
    throw new TypeError('Expected the input to be `string | string[]`');
  }

  options = { ...{
      pascalCase: false
    },
    ...options
  };

  const postProcess = x => options.pascalCase ? x.charAt(0).toLocaleUpperCase() + x.slice(1) : x;

  if (Array.isArray(input)) {
    input = input.map(x => x.trim()).filter(x => x.length).join('-');
  } else {
    input = input.trim();
  }

  if (input.length === 0) {
    return '';
  }

  if (input.length === 1) {
    return options.pascalCase ? input.toLocaleUpperCase() : input.toLocaleLowerCase();
  }

  const hasUpperCase = input !== input.toLocaleLowerCase();

  if (hasUpperCase) {
    input = preserveCamelCase(input);
  }

  input = input.replace(/^[_.\- ]+/, '').toLocaleLowerCase().replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1) => p1.toLocaleUpperCase()).replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, m => m.toLocaleUpperCase());
  return postProcess(input);
};

var camelcase = camelCase; // TODO: Remove this for the next major release

var _default = camelCase;
camelcase.default = _default;

class Property {
  constructor(component) {
    _defineProperty(this, "component", void 0);

    this.component = component;
  }

  get ecs() {
    return this.component.ecs;
  }

  get descriptor() {
    return {
      enumerable: true,
      get: () => this.get(),
      set: v => this.set(v)
    };
  }

  get() {
    return undefined;
  }

  set(value) {}

  serialize() {
    return undefined;
  }

  onDestroyed() {}

  cleanupReference(entity) {}

}

class SimpleProperty extends Property {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "value", null);
  }

  set(value) {
    this.value = value;
  }

  get() {
    return this.value;
  }

  serialize() {
    return this.value;
  }

}

class EntityProperty extends Property {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "id", void 0);
  }

  set(value) {
    if (this.id && (!value || value.id !== this.id || value !== this.id)) {
      this.ecs.entities.removeRef(this.id, this);
    }

    if (value && value.id) {
      this.ecs.entities.addRef(value.id, this);
      this.id = value.id;
      return;
    }

    if (typeof value === 'string') {
      this.ecs.entities.addRef(value, this);
      this.id = value;
      return;
    }

    this.id = undefined;
  }

  get() {
    return this.id && this.component.ecs.getEntity(this.id);
  }

  serialize() {
    return this.id;
  }

  onDestroyed() {
    if (this.id) {
      this.ecs.entities.removeRef(this.id, this);
    }
  }

  cleanupReference(entity) {
    if (this.id === entity.id) {
      this.id = undefined;
    } else {
      console.warn(`Property in unclean state. A reference to an entity "${entity.id}" was never cleaned up.`);
    }
  }

}

class EntityArrayProperty extends Property {
  constructor(component) {
    super(component);

    _defineProperty(this, "proxy", []);

    this.proxy = new Proxy([], {
      get: (target, prop, receiver) => {
        return Reflect.get(target, prop, receiver);
      },
      set: (target, prop, value, receiver) => {
        if (isNaN(prop)) {
          return Reflect.set(target, prop, value, receiver);
        }

        const old = Reflect.get(target, prop, receiver);

        if (typeof value === 'string') {
          value = this.ecs.entities.get(value);
        }

        if (old && old != value) {
          this.ecs.entities.removeRef(value, this);
        }

        if (value && value.id) {
          this.ecs.entities.addRef(value.id, this);
          return Reflect.set(target, prop, value, receiver);
        }

        return Reflect.set(target, prop, value, receiver);
      },
      deleteProperty: (target, prop) => {
        if (isNaN(prop)) {
          return Reflect.deleteProperty(target, prop);
        }

        const value = Reflect.get(target, prop);
        this.ecs.entities.removeRef(value, this);
        return Reflect.deleteProperty(target, prop);
      }
    });
  }

  set(values = []) {
    const len = Math.max(values.length, this.proxy.length);

    for (let i = 0; i < len; i++) {
      if (i in values) {
        this.proxy[i] = values[i];
      } else {
        delete this.proxy[i];
      }
    }

    this.proxy.length = values.length;
  }

  get() {
    return this.proxy;
  }

  serialize() {
    return this.proxy.map(ref => ref.id);
  }

  onDestroyed() {
    this.set([]);
  }

  cleanupReference(entity) {
    this.set(this.proxy.filter(ref => ref.id !== entity.id));
  }

}

class PropertyStrategy {
  static create(component, value) {
    switch (value) {
      case '<Entity>':
        return new EntityProperty(component);

      case '<EntityArray>':
        return new EntityArrayProperty(component);

      default:
        return new SimpleProperty(component);
    }
  }

}

class Component {
  static get type() {
    return this.name;
  }

  get entity() {
    return _classPrivateFieldGet(this, _entity);
  }

  get ecs() {
    return _classPrivateFieldGet(this, _ecs);
  }

  get type() {
    return this.constructor.name;
  }

  get isAttached() {
    return Boolean(this.entity);
  }

  get isDestroyed() {
    return _classPrivateFieldGet(this, _isDestroyed);
  }

  get allowMultiple() {
    return this.constructor.allowMultiple;
  }

  get keyProperty() {
    return this.constructor.keyProperty;
  }

  get properties() {
    const ob = {};

    for (const [key, value] of Object.entries(_classPrivateFieldGet(this, _props))) {
      ob[key] = value.get();
    }

    return ob;
  }

  get key() {
    return this[this.keyProperty];
  }

  constructor(ecs, properties = {}) {
    _entity.set(this, {
      writable: true,
      value: null
    });

    _ecs.set(this, {
      writable: true,
      value: null
    });

    _props.set(this, {
      writable: true,
      value: {}
    });

    _isDestroyed.set(this, {
      writable: true,
      value: false
    });

    _classPrivateFieldSet(this, _ecs, ecs);

    this._defineProxies(properties);
  }

  serialize() {
    return Object.entries(_classPrivateFieldGet(this, _props)).reduce((o, [key, value]) => ({ ...o,
      [key]: value.serialize()
    }), {});
  }

  _onAttached(entity) {
    _classPrivateFieldSet(this, _entity, entity);

    this.ecs.queries.onComponentAdded(entity, this);
    this.onAttached();
  }

  _onDetached() {
    if (this.isAttached) {
      this.onDetached();

      const entity = _classPrivateFieldGet(this, _entity);

      _classPrivateFieldSet(this, _entity, null);

      this.ecs.queries.onComponentRemoved(entity, this);
    }
  }

  _onDestroyed() {
    _classPrivateFieldSet(this, _isDestroyed, true);

    this.onDestroyed();

    for (const prop of Object.values(_classPrivateFieldGet(this, _props))) {
      prop.onDestroyed();
    }
  }

  onAttached() {}

  onDetached() {}

  onDestroyed() {}

  remove(destroy = true) {
    if (this.isAttached) {
      this.entity.remove(this);
    }

    if (destroy) {
      this._onDestroyed();
    }
  }

  destroy() {
    this.remove(true);
  }

  clone() {
    return this.ecs.createComponent(this.type, this.serialize());
  }

  _onEvent(evt) {
    this.onEvent(evt);
    const handlerName = camelcase(`on ${evt.name}`);

    if (typeof this[handlerName] === 'function') {
      this[handlerName](evt);
    }
  }

  onEvent(evt) {}

  _defaultPropertyValue(propertyName) {
    const value = this.constructor.properties[propertyName];

    if (value === '<EntityArray>') {
      return [];
    }

    if (value === '<Entity>') {
      return undefined;
    }

    return value;
  }

  _defineProxies(initialProperties) {
    for (const key in this.constructor.properties) {
      const initialValue = initialProperties.hasOwnProperty(key) ? initialProperties[key] : this._defaultPropertyValue(key);
      const property = PropertyStrategy.create(this, this.constructor.properties[key]);
      _classPrivateFieldGet(this, _props)[key] = property;
      Object.defineProperty(this, key, property.descriptor);
      property.set(initialValue);
    }
  }

}

var _entity = new WeakMap();

var _ecs = new WeakMap();

var _props = new WeakMap();

var _isDestroyed = new WeakMap();

_defineProperty(Component, "allowMultiple", false);

_defineProperty(Component, "keyProperty", null);

_defineProperty(Component, "properties", {});

class ComponentRegistry {
  constructor(ecs) {
    _nameCache.set(this, {
      writable: true,
      value: new Map()
    });

    _definitions.set(this, {
      writable: true,
      value: new Map()
    });

    _ecs$1.set(this, {
      writable: true,
      value: null
    });

    _classPrivateFieldSet(this, _ecs$1, ecs);
  }

  register(component) {
    _classPrivateFieldGet(this, _definitions).set(component.name, component);

    _classPrivateFieldGet(this, _nameCache).set(component.name, camelcase(component.name));
  }

  getAccessor(type) {
    if (_classPrivateFieldGet(this, _nameCache).has(type)) {
      return _classPrivateFieldGet(this, _nameCache).get(type);
    }

    _classPrivateFieldGet(this, _nameCache).set(type, camelcase(type));
  }

  get(typeOrClassOrComponent) {
    const type = this._getType(typeOrClassOrComponent);

    if (!type) {
      console.warn(`Cannot get component definition for type or class ${typeOrClassOrComponent} since it is neither a Component class or type (string)`);
      return null;
    }

    return _classPrivateFieldGet(this, _definitions).get(type);
  }

  create(typeOrClass, properties = {}) {
    const definition = this.get(typeOrClass);

    if (definition) {
      return new definition(_classPrivateFieldGet(this, _ecs$1), properties);
    }

    console.warn(`Could not create component definition for ${typeOrClass} since it is not registered`);
  }

  _getType(typeOrClassOrComponent) {
    if (typeof typeOrClassOrComponent === 'string') {
      return typeOrClassOrComponent;
    }

    if (typeOrClassOrComponent instanceof Component) {
      return typeOrClassOrComponent.type;
    }

    if (typeOrClassOrComponent.prototype instanceof Component) {
      return typeOrClassOrComponent.name;
    }

    return null;
  }

}

var _nameCache = new WeakMap();

var _definitions = new WeakMap();

var _ecs$1 = new WeakMap();

var isMergeableObject = function isMergeableObject(value) {
  return isNonNullObject(value) && !isSpecial(value);
};

function isNonNullObject(value) {
  return !!value && typeof value === 'object';
}

function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
} // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}

function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}

function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}

function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function (element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}

function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge;
  }

  var customMerge = options.customMerge(key);
  return typeof customMerge === 'function' ? customMerge : deepmerge;
}

function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
    return target.propertyIsEnumerable(symbol);
  }) : [];
}

function getKeys(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}

function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_) {
    return false;
  }
} // Protects from prototype poisoning and unexpected merging up the prototype chain.


function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
  && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
  && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
  var destination = {};

  if (options.isMergeableObject(target)) {
    getKeys(target).forEach(function (key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }

  getKeys(source).forEach(function (key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }

    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}

function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
  // implementations can use it. The caller may not replace it.

  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}

deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error('first argument should be an array');
  }

  return array.reduce(function (prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};

var deepmerge_1 = deepmerge;
var cjs = deepmerge_1;

class PrefabComponent {
  get type() {
    return this.componentDef.type;
  }

  constructor(componentDef, properties = {}, overwrite = true) {
    this.componentDef = componentDef;
    this.properties = properties;
    this.overwrite = overwrite;
  }

  applyToEntity(entity, initialProps = {}) {
    if (!this.componentDef.allowMultiple && entity.has(this.componentDef)) {
      if (this.overwrite) {
        entity.remove(this.componentDef);
      } else {
        console.log(`Ignoring prefab component "${this.type}" since the entity "${entity.id}" already has one.`);
        return;
      }
    }

    const props = cjs(this.properties, initialProps);
    entity.add(this.componentDef, props);
  }

}

class Prefab {
  constructor(ecs, name) {
    _defineProperty(this, "name", '');

    _defineProperty(this, "inherit", []);

    _defineProperty(this, "components", []);

    this.ecs = ecs;
    this.name = name;
  }

  addComponent(prefabComponent) {
    this.components.push(prefabComponent);
  }

  applyToEntity(entity, initialProps = {}) {
    this.inherit.forEach(parent => {
      parent.applyToEntity(entity, initialProps);
    });
    const arrComps = {};
    this.components.forEach((component, i) => {
      const definition = component.componentDef;
      const accessor = this.ecs.components.getAccessor(definition.type);
      let initialCompProps = {};

      if (definition.allowMultiple) {
        if (definition.keyProperty) {
          const key = component.properties[definition.keyProperty];

          if (initialProps[accessor] && initialProps[accessor][key]) {
            initialCompProps = initialProps[accessor][key];
          }
        } else {
          if (!arrComps[accessor]) {
            arrComps[accessor] = 0;
          }

          if (initialProps[accessor] && initialProps[accessor][arrComps[accessor]]) {
            initialCompProps = initialProps[accessor][arrComps[accessor]];
          }

          arrComps[accessor]++;
        }
      } else {
        initialCompProps = initialProps[accessor];
      }

      component.applyToEntity(entity, initialCompProps);
    });
    return entity;
  }

}

class PrefabRegistry {
  constructor(ecs) {
    _prefabs.set(this, {
      writable: true,
      value: {}
    });

    _ecs$2.set(this, {
      writable: true,
      value: null
    });

    _classPrivateFieldSet(this, _ecs$2, ecs);
  }

  deserialize(data) {
    const registered = this.get(data.name);

    if (registered) {
      return registered;
    }

    const prefab = new Prefab(_classPrivateFieldGet(this, _ecs$2), data.name);
    let inherit;

    if (Array.isArray(data.inherit)) {
      inherit = data.inherit;
    } else if (typeof data.inherit === 'string') {
      inherit = [data.inherit];
    } else {
      inherit = [];
    }

    prefab.inherit = inherit.map(parent => {
      const ref = this.get(parent);

      if (!ref) {
        console.warn(`Prefab "${data.name}" cannot inherit from Prefab "${parent}" because is not registered yet! Prefabs must be registered in the right order.`);
        return parent;
      }

      return ref;
    });
    const comps = data.components || [];

    for (const componentData of comps) {
      if (typeof componentData === 'string' || componentData.prototype instanceof Component) {
        const def = _classPrivateFieldGet(this, _ecs$2).components.get(componentData);

        if (def) {
          prefab.addComponent(new PrefabComponent(def));
        }
      } else if (typeof componentData === 'object') {
        const type = componentData.type;

        const def = _classPrivateFieldGet(this, _ecs$2).components.get(type);

        if (def) {
          prefab.addComponent(new PrefabComponent(def, componentData.properties, componentData.overwrite));
        }
      } else {
        console.warn(`Unrecognized component reference "${componentData}" in prefab "${data.name}". Ensure the component is registered before the prefab.`);
      }
    }

    this.register(prefab);
    return prefab;
  }

  register(prefab) {
    _classPrivateFieldGet(this, _prefabs)[prefab.name] = prefab;
  }

  get(nameOrClassOrPrefab) {
    const name = PrefabRegistry._getName(nameOrClassOrPrefab);

    return _classPrivateFieldGet(this, _prefabs)[name];
  }

  create(nameOrClass, initialProps = {}) {
    const prefab = this.get(nameOrClass);

    if (!prefab) {
      console.warn(`Could not instantiate prefab for ${nameOrClass} since it is not registered`);
      return;
    }

    const entity = _classPrivateFieldGet(this, _ecs$2).createEntity();

    prefab.applyToEntity(entity, initialProps);
    return entity;
  }

  static _getName(nameOrClassOrPrefab) {
    if (typeof nameOrClassOrPrefab === 'string') {
      return nameOrClassOrPrefab;
    }

    if (nameOrClassOrPrefab instanceof Prefab) {
      return nameOrClassOrPrefab.name;
    }

    if (nameOrClassOrPrefab.prototype instanceof Prefab) {
      return nameOrClassOrPrefab.name;
    }

    return null;
  }

}

var _prefabs = new WeakMap();

var _ecs$2 = new WeakMap();

// This alphabet uses `A-Za-z0-9_-` symbols. The genetic algorithm helped
// optimize the gzip compression for this alphabet.
let urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';

let nanoid = (size = 21) => {
  let id = ''; // A compact alternative for `for (var i = 0; i < step; i++)`.

  let i = size;

  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[Math.random() * 64 | 0];
  }

  return id;
};

class EntityEvent {
  get prevented() {
    return _classPrivateFieldGet(this, _prevented);
  }

  get handled() {
    return _classPrivateFieldGet(this, _handled);
  }

  constructor(name, data = {}) {
    _defineProperty(this, "data", {});

    _prevented.set(this, {
      writable: true,
      value: false
    });

    _handled.set(this, {
      writable: true,
      value: false
    });

    this.name = name;
    this.data = data;
  }

  is(name) {
    return this.name === name;
  }

  handle() {
    _classPrivateFieldSet(this, _handled, true);

    _classPrivateFieldSet(this, _prevented, true);
  }

  prevent() {
    _classPrivateFieldSet(this, _prevented, true);
  }

}

var _prevented = new WeakMap();

var _handled = new WeakMap();

class Entity {
  get ecs() {
    return _classPrivateFieldGet(this, _ecs$3);
  }

  get components() {
    return _classPrivateFieldGet(this, _components);
  }

  get isDestroyed() {
    return _classPrivateFieldGet(this, _isDestroyed$1);
  }

  constructor(ecs, id = null) {
    _id.set(this, {
      writable: true,
      value: null
    });

    _components.set(this, {
      writable: true,
      value: {}
    });

    _ecs$3.set(this, {
      writable: true,
      value: null
    });

    _isDestroyed$1.set(this, {
      writable: true,
      value: false
    });

    _classPrivateFieldSet(this, _ecs$3, ecs);

    _classPrivateFieldSet(this, _id, id || ecs.generateId());

    Object.defineProperty(this, 'id', {
      value: _classPrivateFieldGet(this, _id),
      enumerable: true,
      writable: false
    });
  }

  has(typeOrClass, key = null) {
    const type = this.ecs.components._getType(typeOrClass);

    const accessor = this.ecs.components.getAccessor(type);
    const hasType = this.hasOwnProperty(accessor);

    if (hasType && key) {
      return this[accessor].hasOwnProperty(key);
    }

    return hasType;
  }

  get(typeOrClass, key = null) {
    const type = this.ecs.components._getType(typeOrClass);

    const accessor = this.ecs.components.getAccessor(type);
    const components = this[accessor];

    if (components && key) {
      return components[key];
    }

    return components;
  }

  destroy() {
    _classPrivateFieldSet(this, _isDestroyed$1, true);

    for (const component of Object.values(this.components)) {
      if (component instanceof Component) {
        component.destroy();
      } else {
        for (const nestedComponent of Object.values(component)) {
          nestedComponent.destroy();
        }
      }
    }

    this.ecs.entities.onEntityDestroyed(this);
  }

  add(typeOrClass, properties = {}) {
    const component = this.ecs.components.create(typeOrClass, properties);

    if (!component) {
      console.warn(`"${typeOrClass}" component cannot be added, since it is not registered.`);
      return false;
    }

    return this.attach(component);
  }

  attach(component) {
    const accessor = this.ecs.components.getAccessor(component.type);

    if (!component.allowMultiple) {
      if (this.has(component.type)) {
        console.warn(`"${component.type}" component has allowMultiple set to ${component.allowMultiple}. Trying to add a "${component.type}" component to an entity which already has one.`);
        return false;
      }

      this.components[accessor] = component;
      Object.defineProperty(this, accessor, {
        enumerable: true,
        configurable: true,

        get() {
          return this.components[accessor];
        }

      });

      component._onAttached(this);

      this.ecs.queries.onComponentAdded(this);
      return true;
    }

    if (!component.keyProperty) {
      if (!this.components[accessor]) {
        this.components[accessor] = [];
        Object.defineProperty(this, accessor, {
          configurable: true,
          enumerable: true,

          get() {
            return this.components[accessor];
          }

        });
      }

      this.components[accessor].push(component);

      component._onAttached(this);

      this.ecs.queries.onComponentAdded(this);
      return true;
    }

    if (!component.key) {
      console.warn(`"${component.type}" component has a falsy key of "${component.key}". The keyProperty is set to "${component.keyProperty}".`);
      return false;
    }

    if (!this.components[accessor]) {
      this.components[accessor] = {};
      Object.defineProperty(this, accessor, {
        configurable: true,
        enumerable: true,

        get() {
          return this.components[accessor];
        }

      });
    }

    this.components[accessor][component.key] = component;

    component._onAttached(this);

    this.ecs.queries.onComponentAdded(this, component);
    return true;
  }

  owns(component) {
    return component.entity === this;
  }

  remove(typeOrClassOrComponent, key = null) {
    const isComponent = typeOrClassOrComponent instanceof Component;
    key = isComponent ? typeOrClassOrComponent.key : key;
    const definition = this.ecs.components.get(typeOrClassOrComponent);
    const accessor = this.ecs.components.getAccessor(definition.type);

    if (definition.allowMultiple) {
      if (!definition.keyProperty) {
        if (isComponent) {
          const all = this.components[accessor];

          if (!all) {
            console.warn(`Trying to remove a "${definition.type}" component from an entity, but it wasn't found.`);
            return;
          }

          const index = all.indexOf(typeOrClassOrComponent);

          if (index > -1) {
            all.splice(index, 1);

            typeOrClassOrComponent._onDetached();

            if (all.length === 0) {
              delete this[accessor];
              delete this.components[accessor];
            }

            this.ecs.queries.onComponentRemoved(this);
            return true;
          }
        } else {
          for (const instance of this.components[accessor]) {
            instance._onDetached();
          }

          delete this[accessor];
          delete this.components[accessor];
          this.ecs.queries.onComponentRemoved(this);
          return true;
        }
      }

      if (!key) {
        console.warn(`Trying to remove a "${definition.type}" component which allows multiple without specifying an key.`);
        return;
      }

      const all = this.components[accessor];
      const component = all[key];

      if (component) {
        delete all[key];

        component._onDetached();

        if (Object.keys(all).length <= 0) {
          delete this[accessor];
          delete this.components[accessor];
        }

        this.ecs.queries.onComponentRemoved(this);
        return component;
      } else {
        console.warn(`Trying to remove a "${definition.type}" component from an entity at "${key}", but it wasn't found.`);
        return;
      }
    }

    if (accessor in this) {
      const component = this.components[accessor];
      delete this[accessor];
      delete this.components[accessor];

      component._onDetached();

      this.ecs.queries.onComponentRemoved(this);
      return component;
    }

    console.warn(`Trying to remove a "${definition.type}" component from an entity, but it wasn't found.`);
  }

  serialize() {
    return Object.entries(this.components).reduce((o, [key, value]) => {
      if (value instanceof Component) {
        return { ...o,
          [key]: value.serialize()
        };
      }

      if (Array.isArray(value)) {
        return { ...o,
          [key]: value.map(v => v.serialize())
        };
      }

      return { ...o,
        [key]: Object.entries(value).reduce((o2, [k2, v2]) => ({ ...o2,
          [k2]: v2.serialize()
        }), {})
      };
    }, {
      id: this.id
    });
  }

  fireEvent(name, data) {
    const evt = new EntityEvent(name, data);

    for (const component of Object.values(this.components)) {
      if (component instanceof Component) {
        component._onEvent(evt);

        if (evt.prevented) {
          return evt;
        }
      } else {
        for (const nestedComponent of Object.values(component)) {
          nestedComponent._onEvent(evt);

          if (evt.prevented) {
            return evt;
          }
        }
      }
    }

    return evt;
  }

}

var _id = new WeakMap();

var _components = new WeakMap();

var _ecs$3 = new WeakMap();

var _isDestroyed$1 = new WeakMap();

class EntityRegistry {
  constructor(ecs) {
    _entities.set(this, {
      writable: true,
      value: new Map()
    });

    _ecs$4.set(this, {
      writable: true,
      value: null
    });

    _refs.set(this, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldSet(this, _ecs$4, ecs);
  }

  get all() {
    return _classPrivateFieldGet(this, _entities).values();
  }

  register(entity) {
    _classPrivateFieldGet(this, _entities).set(entity.id, entity);

    return entity;
  }

  get(id) {
    return _classPrivateFieldGet(this, _entities).get(id);
  }

  createOrGetById(id) {
    const entity = this.get(id);

    if (entity) {
      return entity;
    }

    return this.create(id);
  }

  create(id = undefined) {
    const entity = new Entity(_classPrivateFieldGet(this, _ecs$4), id);
    this.register(entity);

    _classPrivateFieldGet(this, _ecs$4).queries.onEntityCreated(entity);

    return entity;
  }

  destroy(entity) {
    entity.destroy();
  }

  onEntityDestroyed(entity) {
    this.cleanupRefs(entity);

    _classPrivateFieldGet(this, _entities).delete(entity.id);

    _classPrivateFieldGet(this, _ecs$4).queries.onEntityDestroyed(entity);
  }

  cleanupRefs(entity) {
    const refs = _classPrivateFieldGet(this, _refs).get(entity.id);

    if (!refs) {
      return;
    }

    for (const ref of refs) {
      ref.cleanupReference(entity);
    }

    delete _classPrivateFieldGet(this, _refs)[entity.id];
  }

  addRef(entityId, property) {
    if (!_classPrivateFieldGet(this, _refs).has(entityId)) {
      _classPrivateFieldGet(this, _refs).set(entityId, new Set([property]));

      return;
    }

    _classPrivateFieldGet(this, _refs).get(entityId).add(property);
  }

  removeRef(entityId, property) {
    if (_classPrivateFieldGet(this, _refs).has(entityId)) {
      _classPrivateFieldGet(this, _refs).get(entityId).delete(property);
    }
  }

  serialize() {
    const json = [];

    _classPrivateFieldGet(this, _entities).forEach(entity => {
      json.push(entity.serialize());
    });

    return json;
  }

  deserialize(data) {
    for (const entityData of data.entities) {
      this.createOrGetById(entityData.id);
    }

    for (const entityData of data.entities) {
      this.deserializeEntity(entityData);
    }
  }

  deserializeEntity(data) {
    const {
      id,
      ...componentData
    } = data;
    const entity = this.createOrGetById(id);
    Object.entries(componentData).forEach(([key, value]) => {
      const type = camelcase(key, {
        pascalCase: true
      });

      const definition = _classPrivateFieldGet(this, _ecs$4).components.get(type);

      if (definition.allowMultiple) {
        Object.values(value).forEach(d => {
          entity.add(definition, d);
        });
      } else {
        entity.add(definition, value);
      }
    });
  }

}

var _entities = new WeakMap();

var _ecs$4 = new WeakMap();

var _refs = new WeakMap();

class Query {
  constructor(ecs, filter = {}) {
    _ecs$5.set(this, {
      writable: true,
      value: void 0
    });

    _filter.set(this, {
      writable: true,
      value: void 0
    });

    _cache.set(this, {
      writable: true,
      value: new Set()
    });

    _classPrivateFieldSet(this, _ecs$5, ecs);

    _classPrivateFieldSet(this, _filter, cjs({
      any: [],
      all: [],
      none: []
    }, filter));

    this.bustCache();
  }

  isMatch(entity) {
    const hasAny = _classPrivateFieldGet(this, _filter).any.length ? _classPrivateFieldGet(this, _filter).any.some(c => entity.has(c)) : true;

    const hasAll = _classPrivateFieldGet(this, _filter).all.every(c => entity.has(c));

    const hasNone = !_classPrivateFieldGet(this, _filter).none.some(c => entity.has(c));
    return hasAny && hasAll && hasNone;
  }

  candidate(entity) {
    if (this.isMatch(entity)) {
      _classPrivateFieldGet(this, _cache).add(entity);

      return true;
    }

    _classPrivateFieldGet(this, _cache).delete(entity);

    return false;
  }

  _onEntityCreated(entity) {
    this.candidate(entity);
  }

  _onComponentAdded(entity) {
    this.candidate(entity);
  }

  _onComponentRemoved(entity) {
    this.candidate(entity);
  }

  _onEntityDestroyed(entity) {
    _classPrivateFieldGet(this, _cache).delete(entity);
  }

  bustCache() {
    _classPrivateFieldGet(this, _cache).clear();

    for (const entity of _classPrivateFieldGet(this, _ecs$5).entities.all) {
      this.candidate(entity);
    }

    return _classPrivateFieldGet(this, _cache);
  }

  get() {
    return _classPrivateFieldGet(this, _cache);
  }

}

var _ecs$5 = new WeakMap();

var _filter = new WeakMap();

var _cache = new WeakMap();

class QueryRegistry {
  constructor(ecs) {
    _ecs$6.set(this, {
      writable: true,
      value: void 0
    });

    _queries.set(this, {
      writable: true,
      value: []
    });

    _classPrivateFieldSet(this, _ecs$6, ecs);
  }

  create(filters) {
    const query = new Query(_classPrivateFieldGet(this, _ecs$6), filters);

    _classPrivateFieldGet(this, _queries).push(query);

    return query;
  }

  onComponentAdded(entity) {
    _classPrivateFieldGet(this, _queries).forEach(query => query._onComponentAdded(entity));
  }

  onComponentRemoved(entity) {
    _classPrivateFieldGet(this, _queries).forEach(query => query._onComponentRemoved(entity));
  }

  onEntityCreated(entity) {
    _classPrivateFieldGet(this, _queries).forEach(query => query._onEntityCreated(entity));
  }

  onEntityDestroyed(entity) {
    _classPrivateFieldGet(this, _queries).forEach(query => query._onEntityDestroyed(entity));
  }

}

var _ecs$6 = new WeakMap();

var _queries = new WeakMap();

class Engine {
  constructor() {
    this.idGenerator = () => nanoid();

    this.components = new ComponentRegistry(this);
    this.prefabs = new PrefabRegistry(this);
    this.entities = new EntityRegistry(this);
    this.queries = new QueryRegistry(this);
  }

  generateId() {
    return this.idGenerator();
  }

  createEntity() {
    return this.entities.create();
  }

  createPrefab(nameOrClass, initialProps = {}) {
    return this.prefabs.create(nameOrClass, initialProps);
  }

  destroyEntity(entity) {
    return this.entities.destroy(entity);
  }

  registerPrefab(data) {
    this.prefabs.deserialize(data);
  }

  registerComponent(component) {
    this.components.register(component);
  }

  getEntity(id) {
    return this.entities.get(id);
  }

  createComponent(type, properties) {
    return this.components.create(type, properties);
  }

  createQuery(filters) {
    return this.queries.create(filters);
  }

  serialize() {
    return {
      entities: this.entities.serialize()
    };
  }

  deserialize(data) {
    if (data.id) {
      return this.entities.deserializeEntity(data);
    }

    return this.entities.deserialize(data);
  }

}

export { Component, Engine, Prefab };
//# sourceMappingURL=index.js.map
